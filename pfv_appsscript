// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PFVMUSIC Complete System - Final Version Ñ Telegram
// Ğ”Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ + ĞŸÑ€Ğ¾Ğ¼Ğ¾ + ĞŸÑ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ñ‹ + Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¾Ğ² + ĞĞ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ + Telegram
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
const SPREADSHEET_ID = '1XlxC6URSsl1UGk2DDw7c8XiJdtz_UHi8ZhTz7S7zXTc';
const DISTRIBUTION_SHEET_NAME = 'Ğ”Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ';
const PROMO_SHEET_NAME = 'ĞŸÑ€Ğ¾Ğ¼Ğ¾';
const PROMO_CODES_SHEET_NAME = 'ĞŸÑ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ñ‹';
const WEB_LOG_SHEET_NAME = 'WebLogs';
const DEBUG_LOGGING = true; // Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

// ID ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
const TEMPLATE_ID = '1MD0F4Ie0WQMCbZxHuwa0v23p836TFNV36MSEVbhBY7g';
// ID Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸ Ğ² Google Drive
const SIGNATURE_FILE_ID = '19Ot12RgTizoTHUitr6Sl7SiiEZ0ZAoXn';
// ID Ğ¿Ğ°Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ HTML Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¾Ğ² (Ğ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾-ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ)
const CONTRACTS_HTML_FOLDER_ID = '';
// ID Ğ¿Ğ°Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ñ‡ĞµĞºĞ¾Ğ² Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ (Ğ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾-ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ)
const PAYMENT_PROOFS_FOLDER_ID = '';

// ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Telegram ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
const TELEGRAM_CONFIG = {
  ENABLED: false,              // â† Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ true Ğ´Ğ»Ñ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
  BOT_TOKEN: '',               // â† Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ñ‚Ğ¾ĞºĞµĞ½ Ğ±Ğ¾Ñ‚Ğ° (Ğ¾Ñ‚ @BotFather)
  CHAT_ID: '',                 // â† Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ ID Ñ‡Ğ°Ñ‚Ğ°/ĞºĞ°Ğ½Ğ°Ğ»Ğ°
  THREAD_ID: null,             // â† ID Ñ‚Ğ¾Ğ¿Ğ¸ĞºĞ° (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾, Ğ´Ğ»Ñ ÑÑƒĞ¿ĞµÑ€Ğ³Ñ€ÑƒĞ¿Ğ¿)
  DEBUG_MODE: false,           // â† true Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸
  NOTIFY_DISTRIBUTION: true,   // Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑÑ‚ÑŒ Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ°Ñ…
  NOTIFY_PROMO: true,          // Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑÑ‚ÑŒ Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ¼Ğ¾
  NOTIFY_PROMO_CODE: false,    // Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑÑ‚ÑŒ Ğ¾ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ğ°Ñ…
  NOTIFY_DOC_GENERATED: true   // Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑÑ‚ÑŒ ĞºĞ¾Ğ³Ğ´Ğ° Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€ ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½
};

// ĞÑ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ‡Ğ°Ñ‚Ğ¾Ğ²/Ğ±Ğ¾Ñ‚Ğ¾Ğ² (ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ñ‹)
const TELEGRAM_DISTRIBUTION = {
  ENABLED: true,
  BOT_TOKEN: '',
  CHAT_ID: '',
  THREAD_ID: null,
  DEBUG_MODE: false
};

const TELEGRAM_PROMO = {
  ENABLED: true,
  BOT_TOKEN: '',
  CHAT_ID: '',
  THREAD_ID: null,
  DEBUG_MODE: false
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ»Ğ¸ÑÑ‚Ğ¾Ğ²
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initializeSheets() {
  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);

  let distributionSheet = spreadsheet.getSheetByName(DISTRIBUTION_SHEET_NAME);
  if (!distributionSheet) {
    distributionSheet = spreadsheet.insertSheet(DISTRIBUTION_SHEET_NAME);
  }
  setupDistributionSheet(distributionSheet);

  let promoSheet = spreadsheet.getSheetByName(PROMO_SHEET_NAME);
  if (!promoSheet) {
    promoSheet = spreadsheet.insertSheet(PROMO_SHEET_NAME);
  }
  setupPromoSheet(promoSheet);

  let promoCodesSheet = spreadsheet.getSheetByName(PROMO_CODES_SHEET_NAME);
  if (!promoCodesSheet) {
    promoCodesSheet = spreadsheet.insertSheet(PROMO_CODES_SHEET_NAME);
  }
  setupPromoCodesSheet(promoCodesSheet);
}

function setupDistributionSheet(sheet) {
  const headers = [
    'timestamp', 'tariff', 'release_type', 'track_count', 'work_title',
    'pseudonym', 'release_version', 'release_link', 'genre', 'language',
    'release_date', 'cover_link', 'tiktok_excerpt', 'tiktok_full', 'yandex_presave',
    'karaoke', 'tracks_json', 'licensor_name', 'passport_series_number', 'passport_issued_by',
    'passport_issue_date', 'bank_details', 'email', 'contact', 'artist_profile_links',
    'base_price', 'karaoke_price', 'total_price', 'payment_proof_url', 'contract_number', 'percentage',
    'contract_status', 'music_author', 'lyrics_author', 'lyrics_texts', 'document_status', 'telegram_status',
    'sign_status', 'sign_token', 'sign_expires_at', 'sign_link', 'sign_doc_id', 'signed_url', 'signed_at',
    'contract_html', 'sign_source', 'signed_pdf_id'
  ];

  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#4A90E2');
  headerRange.setFontColor('#FFFFFF');
  headerRange.setHorizontalAlignment('center');
  headerRange.setVerticalAlignment('middle');
  headerRange.setWrap(true);

  sheet.setColumnWidth(1, 150);
  sheet.setColumnWidth(2, 120);
  sheet.setColumnWidth(3, 120);
  sheet.setColumnWidth(4, 100);
  sheet.setColumnWidth(5, 200);
  sheet.setColumnWidth(6, 150);
  sheet.setColumnWidth(17, 250);
  sheet.setColumnWidth(18, 200);
  sheet.setFrozenRows(1);

  Logger.log('Distribution sheet configured');
}

function setupPromoSheet(sheet) {
  const headers = [
    'timestamp', 'Type', 'release_link', 'upc_or_name', 'release_date',
    'genre', 'focus_track', 'additional_info', 'artist_and_title', 'release_description',
    'artist_info', 'artist_photos', 'social_links', 'contact_info', 'status', 'telegram_status'
  ];

  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#E27D60');
  headerRange.setFontColor('#FFFFFF');
  headerRange.setHorizontalAlignment('center');
  headerRange.setVerticalAlignment('middle');
  headerRange.setWrap(true);

  sheet.setColumnWidth(1, 150);
  sheet.setColumnWidth(2, 120);
  for (let i = 3; i <= headers.length; i++) {
    sheet.setColumnWidth(i, 180);
  }
  sheet.setFrozenRows(1);

  Logger.log('Promo sheet configured');
}

function setupPromoCodesSheet(sheet) {
  const headers = [
    'id', 'code', 'discount_type', 'discount_value', 'applicable_tariffs',
    'applicable_release_types', 'max_uses', 'current_uses', 'is_active',
    'valid_from', 'valid_until', 'created_at', 'description'
  ];

  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#9B59B6');
  headerRange.setFontColor('#FFFFFF');
  headerRange.setHorizontalAlignment('center');
  headerRange.setVerticalAlignment('middle');
  headerRange.setWrap(true);

  sheet.setFrozenRows(1);
  Logger.log('Promo codes sheet configured');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° POST/GET Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function doPost(e) {
  try {
    if (DEBUG_LOGGING) {
      Logger.log('RAW e.postData: ' + (e && e.postData ? JSON.stringify({
        type: e.postData.type || '',
        length: e.postData.length || '',
        contents: e.postData.contents || ''
      }) : 'no postData'));
    }
    logWebRequest('POST', e);
    if (!e) throw new Error('No request data received');

    let data;
    if (e.postData && e.postData.contents) {
      data = JSON.parse(e.postData.contents);
    } else if (e.parameter && e.parameter.data) {
      data = JSON.parse(e.parameter.data);
    } else {
      throw new Error('No data received');
    }

    if (DEBUG_LOGGING) {
      Logger.log('Parsed data: ' + JSON.stringify(data));
    }

    let result = null;
    if (data.action === 'update') {
      updateRowData(data);
    } else if (data.action === 'delete') {
      deleteRowData(data);
    } else if (data.action === 'promo_code_delete') {
      deletePromoCode(data);
    } else if (data.action === 'sign_create') {
      result = createSignLink(data);
    } else if (data.action === 'sign_get') {
      result = getSignData(data);
    } else if (data.action === 'sign_submit') {
      result = submitSignature(data);
    } else if (data.formType === 'promo_code') {
      savePromoCode(data);
    } else if (data.formType === 'distribution') {
      saveDistribution(data);
    } else if (data.formType === 'promo') {
      savePromo(data);
    } else {
      throw new Error('Unknown formType or action: ' + (data.formType || data.action || 'undefined'));
    }

    const responsePayload = result || {
      success: true,
      message: 'Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹',
      formType: data.formType,
      action: data.action
    };
    if (DEBUG_LOGGING) {
      Logger.log('Response payload: ' + JSON.stringify(responsePayload));
    }

    return ContentService
      .createTextOutput(JSON.stringify(responsePayload))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (error) {
    Logger.log('doPost error: ' + error.toString());
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        error: error.toString(),
        stack: error.stack
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function doGet(e) {
  if (!e) e = { parameter: {} };
  if (!e.parameter) e.parameter = {};

  if (e.parameter.action === 'sign_get') {
    try {
      logWebRequest('GET', e);
      const result = getSignData({ token: e.parameter.token || '' });
      return ContentService
        .createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    } catch (error) {
      Logger.log('doGet sign_get error: ' + error.toString());
      return ContentService
        .createTextOutput(JSON.stringify({ success: false, error: error.toString() }))
        .setMimeType(ContentService.MimeType.JSON);
    }
  }

  if (e.parameter.action === 'list') {
    try {
      logWebRequest('GET', e);
      const sheetParam = e.parameter.sheet || '';
      const limit = e.parameter.limit ? parseInt(String(e.parameter.limit), 10) : null;
      const rows = listSheetRows(sheetParam, limit);
      return ContentService
        .createTextOutput(JSON.stringify({ rows: rows }))
        .setMimeType(ContentService.MimeType.JSON);
    } catch (error) {
      Logger.log('doGet list error: ' + error.toString());
      return ContentService
        .createTextOutput(JSON.stringify({ success: false, error: error.toString() }))
        .setMimeType(ContentService.MimeType.JSON);
    }
  }

  if (e.parameter.data) {
    logWebRequest('GET', e);
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        error: 'GET write disabled. Use POST with JSON body.'
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  logWebRequest('GET', e);
  return ContentService
    .createTextOutput(JSON.stringify({
      status: 'ok',
      message: 'PFVMUSIC API is running',
      info: 'Use ?action=list&sheet=distributions to get data',
      hasParameters: !!(e && e.parameter && Object.keys(e.parameter).length > 0)
    }))
    .setMimeType(ContentService.MimeType.JSON);
}

function logWebRequest(method, e) {
  try {
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    let sheet = spreadsheet.getSheetByName(WEB_LOG_SHEET_NAME);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(WEB_LOG_SHEET_NAME);
      sheet.getRange(1, 1, 1, 7).setValues([['ts', 'method', 'params', 'contentType', 'body', 'headers', 'meta']]);
      sheet.setFrozenRows(1);
    }

    const params = e && e.parameter ? JSON.stringify(e.parameter) : '';
    const contentType = e && e.postData ? (e.postData.type || '') : '';
    const body = e && e.postData && e.postData.contents ? e.postData.contents : '';
    const headers = e && e.parameter && e.parameter.headers ? JSON.stringify(e.parameter.headers) : '';
    const meta = JSON.stringify({
      hasPostData: !!(e && e.postData),
      postLength: e && e.postData ? e.postData.length : '',
      userAgent: (e && e.parameter && e.parameter['User-Agent']) ? e.parameter['User-Agent'] : ''
    });

    sheet.appendRow([new Date(), method || '', params, contentType, body, headers, meta]);
  } catch (err) {
    Logger.log('logWebRequest error: ' + err);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function saveDistribution(data) {
  try {
    initializeSheets();
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(DISTRIBUTION_SHEET_NAME);
    if (!sheet) throw new Error('Sheet "' + DISTRIBUTION_SHEET_NAME + '" not found');

    const contractNumber = generateContractNumber();
    const percentage = getTariffPercentage(data.tariff);
    let paymentProofUrl = '';
    if (data.paymentProof) {
      try {
        const proofFile = storePaymentProof(data.paymentProof, contractNumber, data.fullName || '');
        paymentProofUrl = proofFile ? proofFile.getUrl() : '';
      } catch (e) {
        Logger.log('saveDistribution paymentProof error: ' + e);
      }
    }

    const tracksArray = normalizeTracksInput(data.tracks || data.tracks_json || []);
    const authorsFromTracks = extractAuthorsFromTracks(tracksArray);
    const musicAuthorValue = (data.musicAuthor && String(data.musicAuthor).trim())
      ? data.musicAuthor
      : (authorsFromTracks.composers.length ? authorsFromTracks.composers.join(', ') : (data.fullName || ''));
    const lyricsAuthorValue = (data.lyricsAuthor && String(data.lyricsAuthor).trim())
      ? data.lyricsAuthor
      : (authorsFromTracks.lyricists.length ? authorsFromTracks.lyricists.join(', ') : (data.fullName || ''));

    const row = [
      new Date(data.timestamp || new Date()),
      getTariffName(data.tariff),
      getReleaseTypeName(data.releaseType),
      data.trackCount || 0,
      data.releaseName || '',
      data.mainArtist || '',
      data.releaseVersion || '',
      data.releaseLink || '',
      data.genre || '',
      data.language || '',
      data.releaseDate || '',
      data.coverLink || '',
      data.tiktokExcerpt || '',
      data.tiktokFull || '',
      data.yandexPreSave || '',
      data.addKaraoke === 'yes' ? 'Ğ”Ğ°' : 'ĞĞµÑ‚',
      JSON.stringify(tracksArray, null, 2),
      data.fullName || '',
      data.passportNumber || '',
      data.issuedBy || '',
      data.issueDate || '',
      data.bankDetails || '',
      data.email || '',
      data.contactInfo || '',
      data.artistProfileLinks || '',
      Number(data.basePrice || 0),
      Number(data.karaokePrice || 0),
      Number(data.totalPrice || 0),
      paymentProofUrl,
      contractNumber,
      percentage + '%',
      '',
      musicAuthorValue || '',
      lyricsAuthorValue || '',
      collectLyricsFromTracks(tracksArray) || '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      ''
    ];

    sheet.appendRow(row);

    const lastRow = sheet.getLastRow();
    if (lastRow % 2 === 0) {
      sheet.getRange(lastRow, 1, 1, row.length).setBackground('#F9F9F9');
    }
    // number format removed to avoid type conflicts

    Logger.log('Distribution data saved successfully. Contract: ' + contractNumber);

    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ² Telegram
    if (TELEGRAM_CONFIG.ENABLED && TELEGRAM_CONFIG.NOTIFY_DISTRIBUTION) {
      sendDistributionNotification({
        contractNumber: contractNumber,
        licensorName: data.fullName || '',
        pseudonym: data.mainArtist || '',
        tariff: getTariffName(data.tariff),
        releaseType: getReleaseTypeName(data.releaseType),
        releaseDate: data.releaseDate || '',
        workTitle: data.releaseName || '',
        musicAuthor: musicAuthorValue || '',
        lyricsAuthor: lyricsAuthorValue || '',
        email: data.email || '',
        contact: data.contactInfo || '',
        sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
      });
    }

  } catch (error) {
    Logger.log('saveDistribution error: ' + error.toString());
    throw error;
  }
}

function savePromo(data) {
  try {
    initializeSheets();
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(PROMO_SHEET_NAME);
    if (!sheet) throw new Error('Sheet "' + PROMO_SHEET_NAME + '" not found');

    const row = [
      new Date(data.timestamp || new Date()),
      getPromoTypeName(data.promoType),
      data.releaseLink || '',
      data.upcOrName || '',
      data.releaseDate || '',
      data.genre || '',
      data.focusTrack || '',
      data.additionalInfo || '',
      data.artistAndTitle || '',
      data.releaseDescription || '',
      data.artistInfo || '',
      data.artistPhotos || '',
      data.socialLinks || '',
      data.contactInfo || '',
      data.status || ''
    ];

    sheet.appendRow(row);

    const lastRow = sheet.getLastRow();
    if (lastRow % 2 === 0) {
      sheet.getRange(lastRow, 1, 1, row.length).setBackground('#FFF5E6');
    }

    Logger.log('Promo data saved successfully. Type: ' + data.promoType);

    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ² Telegram
    if (TELEGRAM_CONFIG.ENABLED && TELEGRAM_CONFIG.NOTIFY_PROMO) {
      sendPromoNotification({
        promoType: getPromoTypeName(data.promoType),
        releaseLink: data.releaseLink || '',
        upcOrName: data.upcOrName || '',
        releaseDate: data.releaseDate || '',
        genre: data.genre || '',
        focusTrack: data.focusTrack || '',
        artistAndTitle: data.artistAndTitle || '',
        contactInfo: data.contactInfo || '',
        sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
      });
    }

  } catch (error) {
    Logger.log('savePromo error: ' + error.toString());
    throw error;
  }
}

function savePromoCode(data) {
  try {
    initializeSheets();
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(PROMO_CODES_SHEET_NAME);
    if (!sheet) throw new Error('Sheet "' + PROMO_CODES_SHEET_NAME + '" not found');

    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const id = data.id || ('PC-' + Math.random().toString(36).substring(2, 8).toUpperCase());
    const existingRow = findRowById(sheet, headers, id);

    const row = [
      id,
      data.code || '',
      data.discountType || 'percent',
      data.discountValue || 0,
      (data.applicableTariffs || []).join(', '),
      (data.applicableReleaseTypes || []).join(', '),
      data.maxUses || 0,
      data.currentUses || 0,
      data.isActive === false ? false : true,
      data.validFrom || '',
      data.validUntil || '',
      data.createdAt || new Date().toISOString(),
      data.description || ''
    ];

    if (existingRow > 1) {
      sheet.getRange(existingRow, 1, 1, row.length).setValues([row]);
      Logger.log('Promo code updated: ' + id);
    } else {
      sheet.appendRow(row);
      Logger.log('Promo code created: ' + id);

      // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ² Telegram Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸
      if (TELEGRAM_CONFIG.ENABLED && TELEGRAM_CONFIG.NOTIFY_PROMO_CODE) {
        sendPromoCodeNotification({
          id: id,
          code: data.code || '',
          discountType: data.discountType || 'percent',
          discountValue: data.discountValue || 0,
          description: data.description || '',
          sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
        });
      }
    }
  } catch (error) {
    Logger.log('savePromoCode error: ' + error.toString());
    throw error;
  }
}

function deletePromoCode(data) {
  try {
    initializeSheets();
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(PROMO_CODES_SHEET_NAME);
    if (!sheet) throw new Error('Sheet "' + PROMO_CODES_SHEET_NAME + '" not found');

    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const id = data.id || '';
    const rowNum = findRowById(sheet, headers, id);

    if (rowNum > 1) {
      sheet.deleteRow(rowNum);
      Logger.log('Promo code deleted: ' + id);
    } else {
      throw new Error('Promo code not found: ' + id);
    }
  } catch (error) {
    Logger.log('deletePromoCode error: ' + error.toString());
    throw error;
  }
}

function deleteRowData(data) {
  const sheetParam = data.sheet || '';
  const rowNum = parseInt(String(data.row || ''), 10);

  if (!sheetParam || !rowNum) {
    throw new Error('Missing delete parameters');
  }

  const normalized = String(sheetParam || '').toLowerCase().trim();
  let sheetName = sheetParam;

  if (normalized === 'distributions' || normalized === 'distribution' || normalized === 'Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ') {
    sheetName = DISTRIBUTION_SHEET_NAME;
  } else if (normalized === 'promos' || normalized === 'promo' || normalized === 'Ğ¿Ñ€Ğ¾Ğ¼Ğ¾') {
    sheetName = PROMO_SHEET_NAME;
  } else if (normalized === 'promocodes' || normalized === 'promo_codes' || normalized === 'Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ñ‹') {
    sheetName = PROMO_CODES_SHEET_NAME;
  }

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(sheetName);
  if (!sheet) throw new Error('Sheet "' + sheetName + '" not found');

  if (rowNum < 2 || rowNum > sheet.getLastRow()) {
    throw new Error('Invalid row for delete: ' + rowNum);
  }

  sheet.deleteRow(rowNum);
  Logger.log(`Row ${rowNum} deleted from ${sheetName}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ“Ğ•ĞĞ•Ğ ĞĞ¦Ğ˜Ğ¯ Ğ›Ğ˜Ğ¦Ğ•ĞĞ—Ğ˜ĞĞĞĞ«Ğ¥ Ğ”ĞĞšĞ£ĞœĞ•ĞĞ¢ĞĞ’
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateLicenseDocuments() {
  const msg = 'Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· Google Docs Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ°. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğ¹ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½.';
  Logger.log(msg);
  SpreadsheetApp.getActiveSpreadsheet().toast(msg, 'PFVMUSIC', 7);
}

function replaceInTables(body, replacements) {
  const tables = body.getTables();
  tables.forEach(table => {
    for (let r = 0; r < table.getNumRows(); r++) {
      const row = table.getRow(r);
      for (let c = 0; c < row.getNumCells(); c++) {
        const cell = row.getCell(c);
        for (let marker in replacements) {
          cell.replaceText(marker, replacements[marker]);
        }
      }
    }
  });
}

function formatDate(date) {
  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const year = date.getFullYear();
  return `${day}.${month}.${year}`;
}

function insertSignature(body) {
  try {
    const blob = DriveApp.getFileById(SIGNATURE_FILE_ID).getBlob();
    const markers = [
      '{{signature_or}}',
      '{{signature_or_1}}',
      '{{signature_or_2}}',
      '{{signature_or_3}}',
      '{{signature_licensee}}',
      '{{signature_licensor}}',
      '\\\\{\\\\{\\\\s*signature_or\\\\s*\\\\}\\\\}',
      '\\\\{\\\\{\\\\s*signature_licensee\\\\s*\\\\}\\\\}'
    ];
    let ok = false;
    markers.forEach((m) => {
      if (insertSignatureAtMarker(body, m, blob, 120)) ok = true;
    });
    if (!ok) Logger.log('ĞœĞ°Ñ€ĞºĞµÑ€ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸ Ğ»Ğ¸Ñ†ĞµĞ½Ğ·Ğ¸Ğ°Ñ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğµ');
  } catch (error) {
    Logger.log('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²ÑÑ‚Ğ°Ğ²ĞºĞµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸: ' + error.toString());
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TELEGRAM Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ¯
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function sendDistributionNotification(data) {
  const cfg = getTelegramConfig('distribution');
  if (!cfg.ENABLED || !cfg.BOT_TOKEN || !cfg.CHAT_ID) {
    return;
  }

  try {
    const message = buildDistributionMessage(data);
    const result = sendToTelegramAPI(message, cfg);

    if (!result.ok) {
      throw new Error(result.description || "ĞÑˆĞ¸Ğ±ĞºĞ° Telegram API");
    }

    Logger.log("âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾");
  } catch (error) {
    Logger.log("ğŸš¨ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Telegram: " + error.message);
    if (cfg.DEBUG_MODE) {
      sendDebugInfo("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ğ¸: " + error.message, cfg);
    }
  }
}

function sendPromoNotification(data) {
  const cfg = getTelegramConfig('promo');
  if (!cfg.ENABLED || !cfg.BOT_TOKEN || !cfg.CHAT_ID) {
    return;
  }

  try {
    const message = buildPromoMessage(data);
    const result = sendToTelegramAPI(message, cfg);

    if (!result.ok) {
      throw new Error(result.description || "ĞÑˆĞ¸Ğ±ĞºĞ° Telegram API");
    }

    Logger.log("âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾");
  } catch (error) {
    Logger.log("ğŸš¨ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Telegram: " + error.message);
    if (cfg.DEBUG_MODE) {
      sendDebugInfo("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾: " + error.message, cfg);
    }
  }
}

function sendPromoCodeNotification(data) {
  const cfg = getTelegramConfig('promo_code');
  if (!cfg.ENABLED || !cfg.BOT_TOKEN || !cfg.CHAT_ID) {
    return;
  }

  try {
    const message = buildPromoCodeMessage(data);
    const result = sendToTelegramAPI(message, cfg);

    if (!result.ok) {
      throw new Error(result.description || "ĞÑˆĞ¸Ğ±ĞºĞ° Telegram API");
    }

    Logger.log("âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾");
  } catch (error) {
    Logger.log("ğŸš¨ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Telegram: " + error.message);
  }
}

function sendDocumentGeneratedNotification(data) {
  const cfg = getTelegramConfig('document');
  if (!cfg.ENABLED || !cfg.BOT_TOKEN || !cfg.CHAT_ID) {
    return;
  }

  try {
    const message = buildDocumentMessage(data);
    const result = sendToTelegramAPI(message, cfg);

    if (!result.ok) {
      throw new Error(result.description || "ĞÑˆĞ¸Ğ±ĞºĞ° Telegram API");
    }

    Logger.log("âœ… Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾");
  } catch (error) {
    Logger.log("ğŸš¨ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Telegram: " + error.message);
  }
}

function buildDistributionMessage(data) {
  const escapeMd = (text) => {
    if (!text) return '';
    return String(text).replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
  };

  const messageParts = [
    "\\#Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ *ĞĞ¾Ğ²Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ°*\\!",
    "",
    "ğŸ“ *ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ*",
    `â–¸ â„–: ${escapeMd(data.contractNumber)}`,
    `â–¸ Ğ›Ğ¸Ñ†ĞµĞ½Ğ·Ğ¸Ğ°Ñ€: ${escapeMd(data.licensorName)}`,
    `â–¸ ĞŸÑĞµĞ²Ğ´Ğ¾Ğ½Ğ¸Ğ¼: ${escapeMd(data.pseudonym || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ Ğ¢Ğ°Ñ€Ğ¸Ñ„: ${escapeMd(data.tariff)}`,
    `â–¸ Ğ¢Ğ¸Ğ¿ Ñ€ĞµĞ»Ğ¸Ğ·Ğ°: ${escapeMd(data.releaseType || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ Ğ”Ğ°Ñ‚Ğ° Ñ€ĞµĞ»Ğ¸Ğ·Ğ°: ${escapeMd(data.releaseDate || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}`,
    "",
    "ğŸµ *ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ*",
    `â–¸ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: ${escapeMd(data.workTitle || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}`,
    `â–¸ ĞĞ²Ñ‚Ğ¾Ñ€ Ğ¼ÑƒĞ·Ñ‹ĞºĞ¸: ${escapeMd(data.musicAuthor)}`,
    `â–¸ ĞĞ²Ñ‚Ğ¾Ñ€ Ñ‚ĞµĞºÑÑ‚Ğ°: ${escapeMd(data.lyricsAuthor)}`,
    "",
    "ğŸ“ *ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹*",
    `â–¸ Email: ${escapeMd(data.email || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ Ğ¡Ğ²ÑĞ·ÑŒ: ${escapeMd(data.contact || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    "",
    `ğŸ“„ [ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ](${escapeMd(data.sheetUrl)})`
  ];

  return messageParts.join("\n");
}

function buildPromoMessage(data) {
  const escapeMd = (text) => {
    if (!text) return '';
    return String(text).replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
  };

  const messageParts = [
    "\\#Ğ¿Ğ¸Ñ‚Ñ‡Ğ¸Ğ½Ğ³ *ĞĞ¾Ğ²Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ¿Ñ€Ğ¾Ğ¼Ğ¾*\\!",
    "",
    `â–¸ Ğ¢Ğ¸Ğ¿: ${escapeMd(data.promoType)}`,
    `â–¸ ĞÑ€Ñ‚Ğ¸ÑÑ‚ Ğ¸ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: ${escapeMd(data.artistAndTitle || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}`,
    `â–¸ Ğ¡ÑÑ‹Ğ»ĞºĞ°: ${escapeMd(data.releaseLink || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}`,
    `â–¸ UPC: ${escapeMd(data.upcOrName || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ Ğ”Ğ°Ñ‚Ğ° Ñ€ĞµĞ»Ğ¸Ğ·Ğ°: ${escapeMd(data.releaseDate || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')}`,
    `â–¸ Ğ–Ğ°Ğ½Ñ€: ${escapeMd(data.genre || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ Ğ¤Ğ¾ĞºÑƒÑ\\-Ñ‚Ñ€ĞµĞº: ${escapeMd(data.focusTrack || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹: ${escapeMd(data.contactInfo || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ñ‹')}`,
    "",
    `ğŸ“„ [ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ](${escapeMd(data.sheetUrl)})`
  ];

  return messageParts.join("\n");
}

function buildPromoCodeMessage(data) {
  const escapeMd = (text) => {
    if (!text) return '';
    return String(text).replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
  };

  const discountText = data.discountType === 'percent'
    ? `${data.discountValue}%`
    : `${data.discountValue} â‚½`;

  const messageParts = [
    "\\#Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´ *Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´*\\!",
    "",
    `â–¸ ID: ${escapeMd(data.id)}`,
    `â–¸ ĞšĞ¾Ğ´: \`${escapeMd(data.code)}\``,
    `â–¸ Ğ¡ĞºĞ¸Ğ´ĞºĞ°: ${escapeMd(discountText)}`,
    `â–¸ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: ${escapeMd(data.description || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}`,
    "",
    `ğŸ“„ [ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ](${escapeMd(data.sheetUrl)})`
  ];

  return messageParts.join("\n");
}

function buildDocumentMessage(data) {
  const escapeMd = (text) => {
    if (!text) return '';
    return String(text).replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
  };

  const messageParts = [
    "\\#Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€ *Ğ”Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€ ÑĞ¾Ğ·Ğ´Ğ°Ğ½*\\!",
    "",
    `â–¸ â„–: ${escapeMd(data.contractNumber)}`,
    `â–¸ Ğ›Ğ¸Ñ†ĞµĞ½Ğ·Ğ¸Ğ°Ñ€: ${escapeMd(data.licensorName)}`,
    `â–¸ ĞŸÑĞµĞ²Ğ´Ğ¾Ğ½Ğ¸Ğ¼: ${escapeMd(data.pseudonym || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')}`,
    `â–¸ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ: ${escapeMd(data.workTitle || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾')}`,
    "",
    `ğŸ“„ [ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€](${escapeMd(data.docUrl)})`
  ];

  return messageParts.join("\n");
}

function sendToTelegramAPI(message, cfg) {
  const url = `https://api.telegram.org/bot${cfg.BOT_TOKEN}/sendMessage`;

  const chatIdsToTry = [
    cfg.CHAT_ID,
    `-100${cfg.CHAT_ID}`,
    `@${cfg.CHAT_ID}`
  ];

  let lastError;

  for (const chatId of chatIdsToTry) {
    try {
      const payload = {
        chat_id: chatId,
        text: message,
        parse_mode: "MarkdownV2",
        disable_web_page_preview: false
      };

      // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ thread_id ĞµÑĞ»Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ğ½
      if (cfg.THREAD_ID) {
        payload.message_thread_id = cfg.THREAD_ID;
      }

      const response = UrlFetchApp.fetch(url, {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify(payload),
        muteHttpExceptions: true
      });

      const responseData = JSON.parse(response.getContentText());
      if (responseData.ok) return responseData;

      lastError = responseData.description;
    } catch (e) {
      lastError = e.message;
    }
  }

  throw new Error(`Telegram API: ${lastError || "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ"}`);
}

function sendDebugInfo(text, cfg) {
  if (!cfg || !cfg.DEBUG_MODE || !cfg.BOT_TOKEN || !cfg.CHAT_ID) {
    return;
  }

  try {
    const debugUrl = `https://api.telegram.org/bot${cfg.BOT_TOKEN}/sendMessage`;
    const payload = {
      chat_id: cfg.CHAT_ID,
      text: "ğŸ›  DEBUG:\n" + text,
      parse_mode: "MarkdownV2"
    };

    if (cfg.THREAD_ID) {
      payload.message_thread_id = cfg.THREAD_ID;
    }

    UrlFetchApp.fetch(debugUrl, {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
  } catch (e) {
    Logger.log("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ debug info: " + e);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ĞĞ”ĞœĞ˜Ğ-ĞŸĞĞĞ•Ğ›Ğ¬: Ğ§Ñ‚ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getTelegramConfig(kind) {
  const base = TELEGRAM_CONFIG || {};
  let override = null;
  if (kind === 'distribution' || kind === 'document') override = TELEGRAM_DISTRIBUTION;
  if (kind === 'promo' || kind === 'promo_code') override = TELEGRAM_PROMO;

  if (!override) return base;

  return {
    ENABLED: typeof override.ENABLED === 'boolean' ? override.ENABLED : base.ENABLED,
    BOT_TOKEN: override.BOT_TOKEN || base.BOT_TOKEN,
    CHAT_ID: override.CHAT_ID || base.CHAT_ID,
    THREAD_ID: override.THREAD_ID != null ? override.THREAD_ID : base.THREAD_ID,
    DEBUG_MODE: typeof override.DEBUG_MODE === 'boolean' ? override.DEBUG_MODE : base.DEBUG_MODE
  };
}

function getOrCreateColumn(sheet, headerName) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  let idx = headers.indexOf(headerName);
  if (idx >= 0) return idx + 1; // 1-based
  idx = headers.length + 1;
  sheet.getRange(1, idx).setValue(headerName);
  return idx;
}

function sendPendingNotifications() {
  const distCfg = getTelegramConfig('distribution');
  const promoCfg = getTelegramConfig('promo');

  if ((!distCfg.ENABLED || !distCfg.BOT_TOKEN || !distCfg.CHAT_ID) &&
      (!promoCfg.ENABLED || !promoCfg.BOT_TOKEN || !promoCfg.CHAT_ID)) {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Telegram Ğ½Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ ENABLED, BOT_TOKEN Ğ¸ CHAT_ID',
      'Telegram',
      7
    );
    return;
  }

  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);

  // â”€â”€â”€â”€â”€ Distribution â”€â”€â”€â”€â”€
  if (TELEGRAM_CONFIG.NOTIFY_DISTRIBUTION && distCfg.ENABLED && distCfg.BOT_TOKEN && distCfg.CHAT_ID) {
    const sheet = spreadsheet.getSheetByName(DISTRIBUTION_SHEET_NAME);
    if (sheet) {
      const data = sheet.getDataRange().getValues();
      const headers = data[0] || [];
      const idx = {
        contractNumber: headers.indexOf('contract_number'),
        licensorName: headers.indexOf('licensor_name'),
        pseudonym: headers.indexOf('pseudonym'),
        tariff: headers.indexOf('tariff'),
        releaseType: headers.indexOf('release_type'),
        releaseDate: headers.indexOf('release_date'),
        workTitle: headers.indexOf('work_title'),
        musicAuthor: headers.indexOf('music_author'),
        lyricsAuthor: headers.indexOf('lyrics_author'),
        email: headers.indexOf('email'),
        contact: headers.indexOf('contact')
      };

      const telegramCol = getOrCreateColumn(sheet, 'telegram_status');
      for (let r = 1; r < data.length; r++) {
        const row = data[r];
        const currentStatus = row[telegramCol - 1];
        if (currentStatus) continue; // already sent
        if (!row[idx.contractNumber]) continue;

        try {
          sendDistributionNotification({
            contractNumber: row[idx.contractNumber] || '',
            licensorName: row[idx.licensorName] || '',
            pseudonym: row[idx.pseudonym] || '',
            tariff: row[idx.tariff] || '',
            releaseType: row[idx.releaseType] || '',
            releaseDate: row[idx.releaseDate] || '',
            workTitle: row[idx.workTitle] || '',
            musicAuthor: row[idx.musicAuthor] || row[idx.licensorName] || '',
            lyricsAuthor: row[idx.lyricsAuthor] || row[idx.licensorName] || '',
            email: row[idx.email] || '',
            contact: row[idx.contact] || '',
            sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
          });

          sheet.getRange(r + 1, telegramCol).setValue('Sent ' + new Date().toISOString());
        } catch (e) {
          sheet.getRange(r + 1, telegramCol).setValue('Error: ' + e.message);
        }
      }
    }
  }

  // â”€â”€â”€â”€â”€ Promo â”€â”€â”€â”€â”€
  if (TELEGRAM_CONFIG.NOTIFY_PROMO && promoCfg.ENABLED && promoCfg.BOT_TOKEN && promoCfg.CHAT_ID) {
    const sheet = spreadsheet.getSheetByName(PROMO_SHEET_NAME);
    if (sheet) {
      const data = sheet.getDataRange().getValues();
      const headers = data[0] || [];
      const idx = {
        promoType: headers.indexOf('Type'),
        releaseLink: headers.indexOf('release_link'),
        upcOrName: headers.indexOf('upc_or_name'),
        releaseDate: headers.indexOf('release_date'),
        genre: headers.indexOf('genre'),
        focusTrack: headers.indexOf('focus_track'),
        artistAndTitle: headers.indexOf('artist_and_title'),
        contactInfo: headers.indexOf('contact_info')
      };

      const telegramCol = getOrCreateColumn(sheet, 'telegram_status');
      for (let r = 1; r < data.length; r++) {
        const row = data[r];
        const currentStatus = row[telegramCol - 1];
        if (currentStatus) continue;

        try {
          sendPromoNotification({
            promoType: row[idx.promoType] || '',
            releaseLink: row[idx.releaseLink] || '',
            upcOrName: row[idx.upcOrName] || '',
            releaseDate: row[idx.releaseDate] || '',
            genre: row[idx.genre] || '',
            focusTrack: row[idx.focusTrack] || '',
            artistAndTitle: row[idx.artistAndTitle] || '',
            contactInfo: row[idx.contactInfo] || '',
            sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
          });

          sheet.getRange(r + 1, telegramCol).setValue('Sent ' + new Date().toISOString());
        } catch (e) {
          sheet.getRange(r + 1, telegramCol).setValue('Error: ' + e.message);
        }
      }
    }
  }

  SpreadsheetApp.getActiveSpreadsheet().toast(
    'ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°',
    'Telegram',
    5
  );
}

function listSheetRows(sheetParam, limit) {
  initializeSheets();

  const normalized = String(sheetParam || '').toLowerCase().trim();
  let sheetName = sheetParam;
  let sheetType = 'unknown';

  if (normalized === 'distributions' || normalized === 'distribution' || normalized === 'Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ') {
    sheetName = DISTRIBUTION_SHEET_NAME;
    sheetType = 'distribution';
  } else if (normalized === 'promos' || normalized === 'promo' || normalized === 'Ğ¿Ñ€Ğ¾Ğ¼Ğ¾') {
    sheetName = PROMO_SHEET_NAME;
    sheetType = 'promo';
  } else if (normalized === 'promocodes' || normalized === 'promo_codes' || normalized === 'Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ñ‹') {
    sheetName = PROMO_CODES_SHEET_NAME;
    sheetType = 'promocodes';
  }

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(sheetName);
  if (!sheet) throw new Error('Sheet "' + sheetName + '" not found');

  const data = sheet.getDataRange().getValues();
  if (!data || data.length < 2) return [];

  const headers = data[0];
  let rows = data.slice(1);
  if (limit && limit > 0) rows = rows.slice(-limit);

  if (sheetType === 'distribution') {
    return rows.map((r, idx) => {
      const obj = mapDistributionRow(headers, r);
      obj._row = idx + 2;
      return obj;
    });
  }
  if (sheetType === 'promo') {
    return rows.map((r, idx) => {
      const obj = mapPromoRow(headers, r);
      obj._row = idx + 2;
      return obj;
    });
  }
  if (sheetType === 'promocodes') {
    return rows.map((r, idx) => {
      const obj = mapPromoCodeRow(headers, r);
      obj._row = idx + 2;
      return obj;
    });
  }

  return rows.map((r, idx) => ({ index: idx + 1, values: r }));
}

function mapDistributionRow(headers, row) {
  const raw = rowToObject(headers, row);
  return {
    timestamp: normalizeDate(raw.timestamp),
    tariff: normalizeTariff(raw.tariff),
    releaseType: normalizeReleaseType(raw.release_type),
    trackCount: raw.track_count || 0,
    releaseName: raw.work_title || '',
    mainArtist: raw.pseudonym || '',
    releaseVersion: raw.release_version || '',
    releaseLink: raw.release_link || '',
    genre: raw.genre || '',
    language: raw.language || '',
    releaseDate: raw.release_date || '',
    coverLink: raw.cover_link || '',
    tiktokExcerpt: raw.tiktok_excerpt || '',
    tiktokFull: normalizeBool(raw.tiktok_full),
    yandexPreSave: normalizeBool(raw.yandex_presave),
    addKaraoke: normalizeBool(raw.karaoke),
    tracks: raw.tracks_json || '',
    fullName: raw.licensor_name || '',
    passportNumber: raw.passport_series_number || '',
    issuedBy: raw.passport_issued_by || '',
    issueDate: raw.passport_issue_date || '',
    bankDetails: raw.bank_details || '',
    email: raw.email || '',
    contactInfo: raw.contact || '',
    artistProfileLinks: raw.artist_profile_links || '',
    basePrice: normalizeNumber(raw.base_price),
    karaokePrice: normalizeNumber(raw.karaoke_price),
    totalPrice: normalizeNumber(raw.total_price),
    paymentProofUrl: raw.payment_proof_url || '',
    contractNumber: raw.contract_number || '',
    percentage: raw.percentage || '',
    contractStatus: raw.contract_status || '',
    musicAuthor: raw.music_author || '',
    lyricsAuthor: raw.lyrics_author || '',
    documentStatus: raw.document_status || '',
    signStatus: raw.sign_status || '',
    signLink: raw.sign_link || '',
    signExpiresAt: raw.sign_expires_at || '',
    signDocId: raw.sign_doc_id || '',
    signedUrl: raw.signed_url || '',
    signedAt: raw.signed_at || ''
  };
}

function mapPromoRow(headers, row) {
  const raw = rowToObject(headers, row);
  return {
    timestamp: normalizeDate(raw.timestamp),
    promoType: normalizePromoType(raw.Type || raw.type),
    releaseLink: raw.release_link || '',
    upcOrName: raw.upc_or_name || '',
    releaseDate: raw.release_date || '',
    genre: raw.genre || '',
    focusTrack: raw.focus_track || '',
    additionalInfo: raw.additional_info || '',
    artistAndTitle: raw.artist_and_title || '',
    releaseDescription: raw.release_description || '',
    artistInfo: raw.artist_info || '',
    artistPhotos: raw.artist_photos || '',
    socialLinks: raw.social_links || '',
    contactInfo: raw.contact_info || '',
    status: raw.status || ''
  };
}

function mapPromoCodeRow(headers, row) {
  const raw = rowToObject(headers, row);
  return {
    id: raw.id || '',
    code: raw.code || '',
    discountType: raw.discount_type || 'percent',
    discountValue: raw.discount_value || 0,
    applicableTariffs: raw.applicable_tariffs || '',
    applicableReleaseTypes: raw.applicable_release_types || '',
    maxUses: raw.max_uses || 0,
    currentUses: raw.current_uses || 0,
    isActive: normalizeBool(raw.is_active),
    validFrom: raw.valid_from || '',
    validUntil: raw.valid_until || '',
    createdAt: raw.created_at || '',
    description: raw.description || ''
  };
}

function rowToObject(headers, row) {
  const obj = {};
  for (let i = 0; i < headers.length; i++) {
    obj[String(headers[i]).trim()] = row[i];
  }
  return obj;
}

function updateRowData(data) {
  const sheetParam = data.sheet || '';
  const rowNum = parseInt(String(data.row || ''), 10);
  const updates = data.updates || {};

  if (!sheetParam || !rowNum || !updates) {
    throw new Error('Missing update parameters');
  }

  const normalized = String(sheetParam || '').toLowerCase().trim();
  let sheetName = sheetParam;

  if (normalized === 'distributions' || normalized === 'distribution' || normalized === 'Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ') {
    sheetName = DISTRIBUTION_SHEET_NAME;
  } else if (normalized === 'promos' || normalized === 'promo' || normalized === 'Ğ¿Ñ€Ğ¾Ğ¼Ğ¾') {
    sheetName = PROMO_SHEET_NAME;
  } else if (normalized === 'promocodes' || normalized === 'promo_codes' || normalized === 'Ğ¿Ñ€Ğ¾Ğ¼Ğ¾ĞºĞ¾Ğ´Ñ‹') {
    sheetName = PROMO_CODES_SHEET_NAME;
  }

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(sheetName);
  if (!sheet) throw new Error('Sheet "' + sheetName + '" not found');

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

  Object.keys(updates).forEach(function(key) {
    let idx = headers.indexOf(key);
    if (idx < 0) {
      headers.push(key);
      sheet.getRange(1, headers.length).setValue(key);
      idx = headers.length - 1;
    }
    sheet.getRange(rowNum, idx + 1).setValue(updates[key]);
  });

  Logger.log(`Row ${rowNum} updated in ${sheetName}`);
}

function findRowById(sheet, headers, id) {
  if (!id) return -1;
  const idIdx = headers.indexOf('id');
  if (idIdx < 0) return -1;

  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return -1;

  const values = sheet.getRange(2, idIdx + 1, lastRow - 1, 1).getValues();
  for (let i = 0; i < values.length; i++) {
    if (String(values[i][0]) === String(id)) return i + 2;
  }
  return -1;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateContractNumber() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
  return `PFV-${year}${month}-${random}`;
}

function getTariffPercentage(tariff) {
  const percentages = {
    'basic': 55, 'Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹': 55, 'Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹': 55,
    'advanced': 70, 'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹': 70, 'Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹': 70,
    'premium': 90, 'ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼': 90, 'Ğ¿Ñ€ĞµĞ¼Ğ¸ÑƒĞ¼': 90,
    'platinum': 95, 'ĞŸĞ»Ğ°Ñ‚Ğ¸Ğ½ÑƒĞ¼': 95, 'Ğ¿Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑƒĞ¼': 95
  };
  return percentages[tariff] || 55;
}

function getTariffName(tariff) {
  const names = {
    'basic': 'Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹',
    'advanced': 'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹',
    'premium': 'ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼',
    'platinum': 'ĞŸĞ»Ğ°Ñ‚Ğ¸Ğ½ÑƒĞ¼'
  };
  return names[tariff] || tariff || 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½';
}

function getReleaseTypeName(type) {
  const names = {
    'single': 'Ğ¡Ğ¸Ğ½Ğ³Ğ»',
    'ep': 'EP',
    'album': 'ĞĞ»ÑŒĞ±Ğ¾Ğ¼'
  };
  return names[type] || type || 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½';
}

function getPromoTypeName(type) {
  const names = {
    'detailed': 'Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾',
    'weekly': 'Ğ•Ğ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾'
  };
  return names[type] || type || 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½';
}

function normalizeDate(value) {
  if (value instanceof Date) return value.toISOString();
  return value;
}

function normalizeBool(value) {
  if (value === true || value === false) return value;
  if (value === 'Ğ”Ğ°' || value === 'yes' || value === 'true' || value === '1') return true;
  if (value === 'ĞĞµÑ‚' || value === 'no' || value === 'false' || value === '0') return false;
  return !!value;
}

function normalizeNumber(value) {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') {
    const cleaned = value.replace(/[^\d.-]/g, '');
    const n = parseFloat(cleaned);
    return isNaN(n) ? 0 : n;
  }
  return 0;
}

function normalizeTariff(value) {
  const map = {
    'Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹': 'basic',
    'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹': 'advanced',
    'ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼': 'premium',
    'ĞŸĞ»Ğ°Ñ‚Ğ¸Ğ½ÑƒĞ¼': 'platinum'
  };
  return map[value] || value;
}

function normalizeReleaseType(value) {
  const map = {
    'Ğ¡Ğ¸Ğ½Ğ³Ğ»': 'single',
    'EP': 'ep',
    'ĞĞ»ÑŒĞ±Ğ¾Ğ¼': 'album'
  };
  return map[value] || value;
}

function normalizePromoType(value) {
  const map = {
    'Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾': 'detailed',
    'Ğ•Ğ¶ĞµĞ½ĞµĞ´ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾': 'weekly'
  };
  return map[value] || value;
}

function normalizeTracksInput(input) {
  if (!input) return [];
  if (Array.isArray(input)) return input;

  let current = input;
  for (let i = 0; i < 3; i++) {
    if (Array.isArray(current)) return current;
    if (current == null) return [];
    if (typeof current !== 'string') return [];

    const text = String(current).trim();
    if (!text) return [];

    try {
      const parsed = JSON.parse(text);
      if (Array.isArray(parsed)) return parsed;
      if (typeof parsed === 'string') {
        current = parsed;
        continue;
      }
    } catch (e) {
      // Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ñ€Ğ°ÑĞ¿Ğ°Ñ€ÑĞ¸Ñ‚ÑŒ Ğ´Ğ²Ğ¾Ğ¹Ğ½ÑƒÑ ÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ("[...]" ĞºĞ°Ğº ÑÑ‚Ñ€Ğ¾ĞºÑƒ)
      try {
        const unescaped = text
          .replace(/^"+|"+$/g, '')
          .replace(/\\"/g, '"')
          .replace(/\\n/g, '\n')
          .replace(/\\t/g, '\t')
          .replace(/\\r/g, '\r');
        const parsed2 = JSON.parse(unescaped);
        if (Array.isArray(parsed2)) return parsed2;
        if (typeof parsed2 === 'string') {
          current = parsed2;
          continue;
        }
      } catch (e2) {
        // fallback: Ğ²Ñ‹Ñ‚Ğ°Ñ‰Ğ¸Ñ‚ÑŒ JSON Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ¼ĞµĞ¶Ğ´Ñƒ [ Ğ¸ ]
        const start = text.indexOf('[');
        const end = text.lastIndexOf(']');
        if (start >= 0 && end > start) {
          const slice = text.slice(start, end + 1);
          try {
            const parsed3 = JSON.parse(slice);
            if (Array.isArray(parsed3)) return parsed3;
          } catch (e3) {
            try {
              const unescapedSlice = slice
                .replace(/\\"/g, '"')
                .replace(/\\n/g, '\n')
                .replace(/\\t/g, '\t')
                .replace(/\\r/g, '\r');
              const parsed4 = JSON.parse(unescapedSlice);
              if (Array.isArray(parsed4)) return parsed4;
            } catch (e4) {
              break;
            }
          }
        } else {
          break;
        }
      }
    }
  }

  Logger.log('normalizeTracksInput: invalid JSON string');
  return [];
}

function repairTracksJson() {
  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = spreadsheet.getSheetByName(DISTRIBUTION_SHEET_NAME);
  if (!sheet) throw new Error('Sheet "' + DISTRIBUTION_SHEET_NAME + '" not found');

  const data = sheet.getDataRange().getValues();
  const headers = data[0] || [];
  const tracksIdx = headers.indexOf('tracks_json');
  if (tracksIdx < 0) throw new Error('Column "tracks_json" not found');

  const musicAuthorIdx = headers.indexOf('music_author');
  const lyricsAuthorIdx = headers.indexOf('lyrics_author');
  const lyricsTextCol = getOrCreateColumn(sheet, 'lyrics_texts');

  let fixedCount = 0;
  let authorsFixed = 0;
  let lyricsFixed = 0;
  let skipped = 0;
  for (let r = 1; r < data.length; r++) {
    const raw = data[r][tracksIdx];
    if (!raw) continue;
    const normalized = normalizeTracksInput(raw);
    if (!Array.isArray(normalized) || normalized.length === 0) {
      if (String(raw).indexOf('[') >= 0) {
        Logger.log(`repairTracksJson: skip row ${r + 1} (parse failed)`);
        skipped++;
      }
      continue;
    }

    const pretty = JSON.stringify(normalized, null, 2);
    if (String(raw) !== pretty) {
      sheet.getRange(r + 1, tracksIdx + 1).setValue(pretty);
      fixedCount++;
    }

    if (musicAuthorIdx >= 0 && lyricsAuthorIdx >= 0) {
      const currentMusic = data[r][musicAuthorIdx];
      const currentLyrics = data[r][lyricsAuthorIdx];
      if (!currentMusic || !currentLyrics) {
        const authors = extractAuthorsFromTracks(normalized);
        const musicValue = currentMusic || (authors.composers.length ? authors.composers.join(', ') : '');
        const lyricsValue = currentLyrics || (authors.lyricists.length ? authors.lyricists.join(', ') : '');

        if (musicValue && musicValue !== currentMusic) {
          sheet.getRange(r + 1, musicAuthorIdx + 1).setValue(musicValue);
          authorsFixed++;
        }
        if (lyricsValue && lyricsValue !== currentLyrics) {
          sheet.getRange(r + 1, lyricsAuthorIdx + 1).setValue(lyricsValue);
          authorsFixed++;
        }
      }
    }

    const currentLyricsText = data[r][lyricsTextCol - 1];
    if (!currentLyricsText) {
      const lyricsText = collectLyricsFromTracks(normalized);
      if (lyricsText) {
        sheet.getRange(r + 1, lyricsTextCol).setValue(lyricsText);
        lyricsFixed++;
      }
    }
  }

  SpreadsheetApp.getActiveSpreadsheet().toast(
    `ĞŸĞ¾Ñ‡Ğ¸Ğ½ĞµĞ½Ğ¾ tracks_json: ${fixedCount} | ĞĞ²Ñ‚Ğ¾Ñ€Ñ‹: ${authorsFixed} | Ğ¢ĞµĞºÑÑ‚Ñ‹: ${lyricsFixed} | ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº: ${skipped}`,
    'ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ñ‡Ğ¸Ğ½ĞºĞ°',
    5
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ĞŸĞĞ”ĞŸĞ˜Ğ¡ĞĞĞ˜Ğ• Ğ”ĞĞ“ĞĞ’ĞĞ ĞĞ’
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateSignToken() {
  return Utilities.getUuid().replace(/-/g, '');
}

function getSignColumns(sheet) {
  return {
    signStatus: getOrCreateColumn(sheet, 'sign_status'),
    signToken: getOrCreateColumn(sheet, 'sign_token'),
    signExpiresAt: getOrCreateColumn(sheet, 'sign_expires_at'),
    signLink: getOrCreateColumn(sheet, 'sign_link'),
    signDocId: getOrCreateColumn(sheet, 'sign_doc_id'),
    signedUrl: getOrCreateColumn(sheet, 'signed_url'),
    signedAt: getOrCreateColumn(sheet, 'signed_at')
  };
}

function getSignExtraColumns(sheet) {
  return {
    contractHtml: getOrCreateColumn(sheet, 'contract_html'),
    signSource: getOrCreateColumn(sheet, 'sign_source'),
    signedPdfId: getOrCreateColumn(sheet, 'signed_pdf_id')
  };
}

function findRowByContractNumber(sheet, headers, contractNumber) {
  if (!contractNumber) return -1;
  const idx = headers.indexOf('contract_number');
  if (idx < 0) return -1;
  const values = sheet.getRange(2, idx + 1, sheet.getLastRow() - 1, 1).getValues();
  for (let i = 0; i < values.length; i++) {
    if (String(values[i][0]) === String(contractNumber)) return i + 2;
  }
  return -1;
}

function insertSignatureAtMarker(body, marker, blob, widthPx) {
  let range = body.findText(marker);
  let inserted = 0;

  while (range) {
    const el = range.getElement();
    const text = el.asText();
    const start = range.getStartOffset();
    const end = range.getEndOffsetInclusive();
    text.deleteText(start, end);

    const parent = el.getParent();
    if (parent && parent.insertInlineImage) {
      const img = parent.insertInlineImage(parent.getChildIndex(el) + 1, blob);
      if (widthPx) img.setWidth(widthPx);
      inserted++;
    }

    range = body.findText(marker, range);
  }

  return inserted > 0;
}

function dataUrlToBlob(dataUrl) {
  const text = String(dataUrl || '');
  const marker = ';base64,';
  if (text.indexOf('data:') !== 0 || text.indexOf(marker) < 0) {
    throw new Error('Invalid signature data');
  }
  const parts = text.split(marker);
  const contentType = parts[0].slice(5);
  const bytes = Utilities.base64Decode(parts[1] || '');
  return Utilities.newBlob(bytes, contentType, 'signature.png');
}

function buildDocUrls(docId) {
  return {
    docUrl: `https://docs.google.com/document/d/${docId}/edit`,
    previewUrl: `https://docs.google.com/document/d/${docId}/preview`,
    pdfUrl: `https://docs.google.com/document/d/${docId}/export?format=pdf`
  };
}

function createDocFromHtml(html, fileName) {
  throw new Error('Google Docs disabled. Use internal HTML signing flow.');
}

function createPdfFromHtml(html, fileName) {
  if (!html) throw new Error('Empty contractHtml');
  const htmlBlob = Utilities.newBlob(String(html), MimeType.HTML, `${fileName}.html`);

  // Always use DriveApp to avoid Advanced Drive Service dependency
  const tempFile = DriveApp.createFile(htmlBlob);
  try {
    const pdfBlob = tempFile.getAs(MimeType.PDF).setName(`${fileName} (signed).pdf`);
    let pdfFile = null;
    const parents = tempFile.getParents();
    if (parents.hasNext()) {
      pdfFile = parents.next().createFile(pdfBlob);
    } else {
      pdfFile = DriveApp.createFile(pdfBlob);
    }
    makeFilePublic(pdfFile);
    return pdfFile;
  } finally {
    try {
      tempFile.setTrashed(true);
    } catch (e) {
      Logger.log('createPdfFromHtml: failed to trash temp file: ' + e);
    }
  }
}

function buildDriveDownloadUrl(fileId) {
  return `https://drive.google.com/uc?export=download&id=${fileId}`;
}

function makeFilePublic(file) {
  try {
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
  } catch (e) {
    Logger.log('makeFilePublic error: ' + e);
  }
}

function extractDriveFileId(value) {
  const text = String(value || '');
  if (!text) return '';
  if (text.indexOf('drive:') === 0) {
    return text.slice('drive:'.length).trim();
  }
  let m = text.match(/drive\.google\.com\/uc\?export=download&id=([^&]+)/i);
  if (m && m[1]) return m[1];
  m = text.match(/drive\.google\.com\/file\/d\/([^/]+)/i);
  if (m && m[1]) return m[1];
  m = text.match(/drive\.google\.com\/open\?id=([^&]+)/i);
  if (m && m[1]) return m[1];
  return '';
}

function getOrCreateContractsHtmlFolder() {
  if (CONTRACTS_HTML_FOLDER_ID) {
    try {
      return DriveApp.getFolderById(CONTRACTS_HTML_FOLDER_ID);
    } catch (e) {
      Logger.log('getOrCreateContractsHtmlFolder: invalid folder id: ' + e);
    }
  }
  const folderName = 'PFV Contracts HTML';
  const existing = DriveApp.getFoldersByName(folderName);
  if (existing.hasNext()) return existing.next();
  return DriveApp.createFolder(folderName);
}

function getOrCreatePaymentProofsFolder() {
  if (PAYMENT_PROOFS_FOLDER_ID) {
    try {
      return DriveApp.getFolderById(PAYMENT_PROOFS_FOLDER_ID);
    } catch (e) {
      Logger.log('getOrCreatePaymentProofsFolder: invalid folder id: ' + e);
    }
  }
  const folderName = 'PFV Payment Proofs';
  const existing = DriveApp.getFoldersByName(folderName);
  if (existing.hasNext()) return existing.next();
  return DriveApp.createFolder(folderName);
}

function storePaymentProof(dataUrl, contractNumber, licensorName) {
  const blob = dataUrlToBlob(dataUrl);
  const safeName = `ĞĞ¿Ğ»Ğ°Ñ‚Ğ° ${contractNumber || 'PFV'} - ${licensorName || 'ĞšĞ»Ğ¸ĞµĞ½Ñ‚'}`.trim();
  blob.setName(`${safeName}`);
  const folder = getOrCreatePaymentProofsFolder();
  const file = folder.createFile(blob);
  makeFilePublic(file);
  return file;
}

function storeContractHtml(html, fileName, existingValue) {
  const text = String(html || '');
  if (!text) return { mode: 'inline', value: '' };

  // Reuse existing Drive file when possible
  const existingFileId = extractDriveFileId(existingValue);
  if (existingFileId) {
    try {
      const existingFile = DriveApp.getFileById(existingFileId);
      existingFile.setContent(text);
      return { mode: 'drive', value: buildDriveDownloadUrl(existingFileId) };
    } catch (e) {
      Logger.log('storeContractHtml: failed to reuse existing file: ' + e);
    }
  }

  const safeName = fileName ? `${fileName} (html)` : 'Contract HTML';
  const blob = Utilities.newBlob(text, MimeType.HTML, `${safeName}.html`);
  const folder = getOrCreateContractsHtmlFolder();
  const file = folder.createFile(blob);
  makeFilePublic(file);
  // Store only a download link in the sheet, never full HTML
  return { mode: 'drive', value: buildDriveDownloadUrl(file.getId()) };
}

function resolveContractHtml(value) {
  const text = String(value || '');
  if (!text) return '';
  const fileId = extractDriveFileId(text);

  if (!fileId) {
    // Not a Drive link, treat as inline HTML (legacy)
    return text;
  }

  try {
    return DriveApp.getFileById(fileId).getBlob().getDataAsString();
  } catch (e) {
    Logger.log('resolveContractHtml error: ' + e);
    return '';
  }
}

function embedOwnerSignatureInHtml(html) {
  try {
    const blob = DriveApp.getFileById(SIGNATURE_FILE_ID).getBlob();
    const contentType = blob.getContentType() || 'image/png';
    const b64 = Utilities.base64Encode(blob.getBytes());
    const imgTag = `<img src="data:${contentType};base64,${b64}" style="height:60px;width:auto;" />`;
    const markers = [
      '{{signature_or}}',
      '{{signature_or_1}}',
      '{{signature_or_2}}',
      '{{signature_or_3}}',
      '{{signature_licensee}}',
      '{{signature_licensor}}',
      '{{ signature_or }}',
      '{{ signature_licensee }}'
    ];
    let result = String(html);
    markers.forEach(m => { result = result.split(m).join(imgTag); });
    result = result.replace(/\{\{\s*signature_or\s*\}\}/g, imgTag);
    result = result.replace(/\{\{\s*signature_licensee\s*\}\}/g, imgTag);
    return result;
  } catch (e) {
    Logger.log('embedOwnerSignatureInHtml error: ' + e);
    return html;
  }
}

function injectSignatureIntoHtml(html, signatureDataUrl) {
  if (!html) return '';
  const imgTag = `<img src="${signatureDataUrl}" style="height:60px;width:auto;" />`;
  const markers = [
    '{{signature_client}}',
    '{{signature_client_1}}',
    '{{signature_client_2}}',
    '{{signature_client_3}}',
    '{{ signature_client }}'
  ];
  let result = String(html);
  markers.forEach(m => {
    result = result.split(m).join(imgTag);
  });
  // also handle regex-like escaped markers if present
  result = result.replace(/\{\{\s*signature_client\s*\}\}/g, imgTag);
  return result;
}

function createSignLink(data) {
  initializeSheets();
  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = spreadsheet.getSheetByName(DISTRIBUTION_SHEET_NAME);
  if (!sheet) throw new Error('Sheet "' + DISTRIBUTION_SHEET_NAME + '" not found');

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const rowIndex = data.row ? parseInt(String(data.row), 10) : findRowByContractNumber(sheet, headers, data.contractNumber);
  if (!rowIndex || rowIndex < 2) return { success: false, error: 'Row not found for contract' };

  const row = sheet.getRange(rowIndex, 1, 1, headers.length).getValues()[0];
  const idx = {
    contractNumber: headers.indexOf("contract_number"),
    licensorName: headers.indexOf("licensor_name"),
    tariff: headers.indexOf("tariff"),
    passportSeriesNumber: headers.indexOf("passport_series_number"),
    passportIssuedBy: headers.indexOf("passport_issued_by"),
    passportIssueDate: headers.indexOf("passport_issue_date"),
    bankDetails: headers.indexOf("bank_details"),
    email: headers.indexOf("email"),
    pseudonym: headers.indexOf("pseudonym"),
    workTitle: headers.indexOf("work_title"),
    musicAuthor: headers.indexOf("music_author"),
    lyricsAuthor: headers.indexOf("lyrics_author")
  };

  const contractNumber = row[idx.contractNumber] || data.contractNumber;
  if (!contractNumber) return { success: false, error: 'Missing contract_number' };

  const currentDate = new Date();
  const formattedDate = formatDate(currentDate);
  const futureDate = new Date();
  futureDate.setFullYear(currentDate.getFullYear() + 4);
  const formattedFutureDate = formatDate(futureDate);

  let percentageText = '';
  const tariff = row[idx.tariff] || '';
  switch (tariff) {
    case 'Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹':
      percentageText = '55% (ĞŸÑÑ‚ÑŒĞ´ĞµÑÑÑ‚ Ğ¿ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ¾Ğ²)';
      break;
    case 'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹':
      percentageText = '70% (Ğ¡ĞµĞ¼ÑŒĞ´ĞµÑÑÑ‚ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ¾Ğ²)';
      break;
    case 'ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼':
      percentageText = '90% (Ğ”ĞµĞ²ÑĞ½Ğ¾ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ¾Ğ²)';
      break;
    case 'ĞŸĞ»Ğ°Ñ‚Ğ¸Ğ½ÑƒĞ¼':
      percentageText = '95% (Ğ”ĞµĞ²ÑĞ½Ğ¾ÑÑ‚Ğ¾ Ğ¿ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ¾Ğ²)';
      break;
    default:
      percentageText = '55% (ĞŸÑÑ‚ÑŒĞ´ĞµÑÑÑ‚ Ğ¿ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ¾Ğ²)';
  }

  const replacements = {
    '{{contract_number}}': contractNumber,
    '{{licensor_name}}': row[idx.licensorName] || 'Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸',
    '{{date}}': formattedDate,
    '{{future_date}}': formattedFutureDate,
    '{{percentage}}': percentageText,
    '{{passport_series_number}}': row[idx.passportSeriesNumber] || '',
    '{{passport_issued_by}}': row[idx.passportIssuedBy] || '',
    '{{passport_issue_date}}': row[idx.passportIssueDate] || '',
    '{{bank_details}}': row[idx.bankDetails] || '',
    '{{email}}': row[idx.email] || '',
    '{{pseudonym}}': row[idx.pseudonym] || '',
    '{{work_title}}': row[idx.workTitle] || '',
    '{{music_author}}': row[idx.musicAuthor] || '',
    '{{lyrics_author}}': row[idx.lyricsAuthor] || ''
  };

  const licensorName = replacements['{{licensor_name}}'] || 'Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸';
  const fileName = `Ğ”Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€ â„–${contractNumber} - ${licensorName}`;
  let contractHtml = data.contractHtml ? String(data.contractHtml) : '';
  const signCols = getSignColumns(sheet);
  const extraCols = getSignExtraColumns(sheet);

  if (!contractHtml) {
    const existingHtml = row[extraCols.contractHtml - 1];
    if (existingHtml) contractHtml = resolveContractHtml(existingHtml);
  }

  if (!contractHtml) {
    return { success: false, error: 'Missing contractHtml for internal signing' };
  }

  const htmlWithOwnerSig = embedOwnerSignatureInHtml(contractHtml);
  const existingHtml = row[extraCols.contractHtml - 1];
  const stored = storeContractHtml(htmlWithOwnerSig, fileName, existingHtml);
  sheet.getRange(rowIndex, extraCols.contractHtml).setValue(stored.value);
  sheet.getRange(rowIndex, extraCols.signSource).setValue('internal');
  sheet.getRange(rowIndex, signCols.signDocId).setValue('');

  const signBaseUrl = String(data.signBaseUrl || '').replace(/\/$/, '');
  if (!signBaseUrl) return { success: false, error: 'Missing signBaseUrl' };

  const token = generateSignToken();
  const expiresDays = Number(data.signExpiresDays || 7);
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + (Number.isFinite(expiresDays) && expiresDays > 0 ? expiresDays : 7));

  const signUrl = `${signBaseUrl}/sign.html?token=${token}`;
  sheet.getRange(rowIndex, signCols.signStatus).setValue('pending');
  sheet.getRange(rowIndex, signCols.signToken).setValue(token);
  sheet.getRange(rowIndex, signCols.signExpiresAt).setValue(expiresAt.toISOString());
  sheet.getRange(rowIndex, signCols.signLink).setValue(signUrl);
  sheet.getRange(rowIndex, signCols.signedUrl).setValue('');
  sheet.getRange(rowIndex, signCols.signedAt).setValue('');
  sheet.getRange(rowIndex, extraCols.signedPdfId).setValue('');

  return {
    success: true,
    signUrl,
    expiresAt: expiresAt.toISOString(),
    docUrl: '',
    previewUrl: '',
    pdfUrl: ''
  };
}

function getSignData(data) {
  const token = String(data.token || '').trim();
  if (!token) return { success: false, error: 'Missing token' };

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(DISTRIBUTION_SHEET_NAME);
  if (!sheet) return { success: false, error: 'Sheet not found' };
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const signCols = getSignColumns(sheet);
  const extraCols = getSignExtraColumns(sheet);

  const signTokenIdx = signCols.signToken - 1;
  const signExpiresIdx = signCols.signExpiresAt - 1;
  const signDocIdIdx = signCols.signDocId - 1;
  const signStatusIdx = signCols.signStatus - 1;
  const signedUrlIdx = signCols.signedUrl - 1;
  const contractHtmlIdx = extraCols.contractHtml - 1;
  const signSourceIdx = extraCols.signSource - 1;
  const signedPdfIdIdx = extraCols.signedPdfId - 1;

  const dataRange = sheet.getDataRange().getValues();
  for (let r = 1; r < dataRange.length; r++) {
    const row = dataRange[r];
    if (String(row[signTokenIdx]) !== token) continue;

    const expiresAt = row[signExpiresIdx] ? new Date(row[signExpiresIdx]) : null;
    if (expiresAt && expiresAt.getTime() < Date.now()) {
      return { success: false, error: 'Token expired' };
    }

  const contractHtml = resolveContractHtml(row[contractHtmlIdx] || '');
  const signedPdfId = row[signedPdfIdIdx] || '';
  if (!contractHtml) return { success: false, error: 'Internal contract HTML missing' };

  return {
    success: true,
    status: row[signStatusIdx] || 'pending',
    signedUrl: row[signedUrlIdx] || '',
    expiresAt: expiresAt ? expiresAt.toISOString() : '',
    signSource: 'internal',
    contractHtml: contractHtml || '',
    signedPdfId: signedPdfId || '',
    docUrl: '',
    previewUrl: '',
    pdfUrl: ''
  };
}

  return { success: false, error: 'Token not found' };
}

function submitSignature(data) {
  const token = String(data.token || '').trim();
  if (!token) return { success: false, error: 'Missing token' };
  if (!data.signature) return { success: false, error: 'Missing signature' };

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(DISTRIBUTION_SHEET_NAME);
  if (!sheet) return { success: false, error: 'Sheet not found' };
  const signCols = getSignColumns(sheet);
  const extraCols = getSignExtraColumns(sheet);
  const dataRange = sheet.getDataRange().getValues();

  for (let r = 1; r < dataRange.length; r++) {
    const row = dataRange[r];
    if (String(row[signCols.signToken - 1]) !== token) continue;

    const expiresAt = row[signCols.signExpiresAt - 1] ? new Date(row[signCols.signExpiresAt - 1]) : null;
    if (expiresAt && expiresAt.getTime() < Date.now()) {
      return { success: false, error: 'Token expired' };
    }

    const contractHtml = resolveContractHtml(row[extraCols.contractHtml - 1]);
    if (!contractHtml) return { success: false, error: 'Internal contract HTML missing' };

    // Internal HTML flow: inject signature and render PDF
    const signedHtml = injectSignatureIntoHtml(contractHtml, data.signature);
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const idx = {
      contractNumber: headers.indexOf("contract_number"),
      licensorName: headers.indexOf("licensor_name")
    };
    const contractNumber = row[idx.contractNumber] || 'UNKNOWN';
    const licensorName = row[idx.licensorName] || 'Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸';
    const fileName = `Ğ”Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€ â„–${contractNumber} - ${licensorName}`;

    const pdfFile = createPdfFromHtml(signedHtml, fileName);
    const signedUrl = pdfFile.getUrl();
    const downloadUrl = `https://drive.google.com/uc?export=download&id=${pdfFile.getId()}`;

    sheet.getRange(r + 1, signCols.signStatus).setValue('signed');
    sheet.getRange(r + 1, signCols.signedUrl).setValue(signedUrl);
    sheet.getRange(r + 1, signCols.signedAt).setValue(new Date().toISOString());
    sheet.getRange(r + 1, extraCols.signedPdfId).setValue(pdfFile.getId());
    const contractStatusCol = getOrCreateColumn(sheet, 'contract_status');
    sheet.getRange(r + 1, contractStatusCol).setValue('signed');

    return { success: true, signedUrl, downloadUrl };
  }

  return { success: false, error: 'Token not found' };
}

function extractAuthorsFromTracks(tracks) {
  const composers = new Set();
  const lyricists = new Set();

  const addNames = (set, value) => {
    if (!value) return;
    if (Array.isArray(value)) {
      value.forEach(v => addNames(set, v));
      return;
    }
    const text = String(value);
    text.split(',').map(s => s.trim()).filter(Boolean).forEach(name => set.add(name));
  };

  (tracks || []).forEach(track => {
    if (!track) return;
    addNames(composers, track.composers || track.musicAuthors || track.musicAuthor);
    addNames(lyricists, track.lyricists || track.lyricsAuthors || track.lyricsAuthor);
  });

  return {
    composers: Array.from(composers),
    lyricists: Array.from(lyricists)
  };
}

function collectLyricsFromTracks(tracks) {
  const parts = [];
  (tracks || []).forEach(track => {
    if (!track) return;
    const lyrics = track.lyrics || track.lyricsText || track.text || '';
    if (!lyrics) return;
    const num = track.number ? String(track.number) : '';
    const name = track.name ? String(track.name) : '';
    const title = [num, name].filter(Boolean).join('. ');
    parts.push(title ? `${title}\n${lyrics}` : String(lyrics));
  });
  if (!parts.length) return '';
  return parts.join('\n\n---\n\n');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ñ€ÑƒÑ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¾Ğ²
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateExistingSheets() {
  Logger.log('Starting sheets update...');
  initializeSheets();
  Logger.log('Sheets updated successfully!');
  SpreadsheetApp.getActiveSpreadsheet().toast(
    'Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸ Ğ²ÑĞµÑ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ† Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹',
    'Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾',
    3
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¾Ğ³Ğ¾ Ğ¼ĞµĞ½Ñ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('ğŸ“„ PFVMUSIC')
    .addItem('ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†', 'updateExistingSheets')
    .addItem('ğŸ›  ĞŸĞ¾Ñ‡Ğ¸Ğ½Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞºĞ¾Ğ²', 'repairTracksJson')
    .addSeparator()
    .addItem('ğŸ“ Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ñ‹', 'generateLicenseDocuments')
    .addSeparator()
    .addItem('ğŸ“² ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ (Ñ€ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº)', 'sendPendingNotifications')
    .addItem('ğŸ“² Ğ¢ĞµÑÑ‚ Telegram (Ğ´Ğ¸ÑÑ‚Ñ€Ğ¸Ğ±ÑƒÑ†Ğ¸Ñ)', 'testTelegramDistribution')
    .addItem('ğŸ“² Ğ¢ĞµÑÑ‚ Telegram (Ğ¿Ñ€Ğ¾Ğ¼Ğ¾)', 'testTelegramPromo')
    .addToUi();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Telegram
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function testTelegramDistribution() {
  const testData = {
    contractNumber: 'TEST-2026-0001',
    licensorName: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞÑ€Ñ‚Ğ¸ÑÑ‚',
    pseudonym: 'Test MC',
    tariff: 'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹',
    releaseType: 'Ğ¡Ğ¸Ğ½Ğ³Ğ»',
    releaseDate: '2026-03-15',
    workTitle: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚Ñ€ĞµĞº',
    musicAuthor: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞÑ€Ñ‚Ğ¸ÑÑ‚',
    lyricsAuthor: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞÑ€Ñ‚Ğ¸ÑÑ‚',
    email: 'test@test.ru',
    contact: '+7 999 123 45 67',
    sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
  };
  
  try {
    sendDistributionNotification(testData);
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾!',
      'Telegram',
      5
    );
  } catch (error) {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'ĞÑˆĞ¸Ğ±ĞºĞ°: ' + error.message,
      'Telegram',
      10
    );
  }
}

function testTelegramPromo() {
  const testData = {
    promoType: 'Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ¼Ğ¾',
    artistAndTitle: 'Test Artist - Test Track',
    releaseLink: 'https://example.com',
    upcOrName: '1234567890',
    releaseDate: '2026-03-15',
    genre: 'Pop',
    focusTrack: 'Test Track',
    contactInfo: 'test@test.ru',
    sheetUrl: SpreadsheetApp.getActiveSpreadsheet().getUrl()
  };
  
  try {
    sendPromoNotification(testData);
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾!',
      'Telegram',
      5
    );
  } catch (error) {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'ĞÑˆĞ¸Ğ±ĞºĞ°: ' + error.message,
      'Telegram',
      10
    );
  }
}
